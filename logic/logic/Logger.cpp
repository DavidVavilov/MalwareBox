#include "Logger.h"

void Logger::writeLogToFile(const std::string& logString, const std::string& fileName)
{
    std::ofstream out(fileName);
    out << logString;
    out.close();
}

void Logger::combineLogFiles()
{
    std::ifstream fileIn;
    std::ofstream fileOut(OUTPUT_FILE);

    fileOut << "MalwareBox Log" << std::endl << std::endl;
    fileOut << "Static Scans:" << std::endl;
    for (size_t i = 0; i < NUM_OF_FILES; i++)
    {
        switch (i)
        {
            case 0:
                fileIn.open(STRINGS_FILE);
                if (fileIn)
                {
                    if (is_empty(fileIn))
                    {
                        fileOut << "StringsScan:" << std::endl << std::endl;
                    }
                    else
                    {
                        fileOut << "StringsScan:" << std::endl << fileIn.rdbuf() << std::endl;
                    }
                }
                fileIn.close();
                break;
            case 1:
                fileIn.open(VIRUSTOTAL_FILE);
                if (fileIn)
                {
                    if (is_empty(fileIn))
                    {
                        fileOut << "VirusTotal:" << std::endl << std::endl;
                    }
                    else
                    {
                        fileOut << "VirusTotal:" << std::endl << fileIn.rdbuf() << std::endl;
                    }
                }
                fileIn.close();
                break;
            case 2:
                fileIn.open(YARA_FILE);
                if (fileIn)
                {
                    if (is_empty(fileIn))
                    {
                        fileOut << "YaraScan:" << std::endl << std::endl;
                    }
                    else
                    {
                        fileOut << "YaraScan:" << std::endl << fileIn.rdbuf() << std::endl;
                    }
                }
                fileIn.close();
                break;
            case 3:

                fileOut << "Dynamic Scans:" << std::endl;

                fileIn.open(PACKET_FILE);
                if (fileIn)
                {
                    if (is_empty(fileIn))
                    {
                        fileOut << "packetScan:" << std::endl <<  std::endl;
                    }
                    else
                    {
                        fileOut << "packetScan:" << std::endl << fileIn.rdbuf() << std::endl;
                    }
                }
                fileIn.close();
                break;
            case 4:
                fileIn.open(PROCESS_FILE);
                if (fileIn)
                {
                    if (is_empty(fileIn))
                    {
                        fileOut << "processScan:" << std::endl << std::endl;
                    }
                    else
                    {
                        fileOut << "processScan:" << std::endl << fileIn.rdbuf() << std::endl;
                    }
                }
                else
                {
                    fileOut << "processScan:" << std::endl << std::endl;
                }
                fileIn.close();
                break;
            case 5:
                fileIn.open(REGISTRY_FILE);
                if (fileIn)
                {
                    if (is_empty(fileIn))
                    {
                        fileOut << "registryScan:" << std::endl << std::endl;
                    }
                    else
                    {
                        fileOut << "registryScan:" << std::endl << fileIn.rdbuf() << std::endl;
                    }
                }
                else
                {
                    fileOut << "registryScan:" << std::endl << std::endl;
                }
                fileIn.close();
                break;
        default:
            break;
        }
    }
}

bool Logger::is_empty(std::ifstream& pFile)
{
    return pFile.peek() == std::ifstream::traits_type::eof();
}
